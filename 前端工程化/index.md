## 前端工程化

**前端工程化 是 以规范工作流程为手段，以工具为实现媒介，其最终目的是为了提高研发效率以及web产品的线上质量。**

### 规范：
```
 1. 项目文件的组织结构，比如使用目录名称区分源文件 和 目标文件
 2. 源代码的开发范式，比如使用既定的模块化方案
 3. 工具的使用规范，比如工程化自身的配置规范
 4. 各阶段环境的依赖，比如部署功能的实现需要目标服务器提供SSH权限
```

### JavaScript

javascript = ECMAScript + DOM + BOM
javascript = ECMAScript + 宿主API

### Babel
将浏览器未实现的ECMAScript规范预发转化为可运行的低版本语法

### 按需加载
```
1. 模块化规范的依赖管理功能可以让按需加载更加易于管理
2. 使用模块化构建工具将同步的散列模块进行合并打包，减少了客户端的HTTP请求数量
3. 细粒度的模块划分搭配动态加载 令Web应用程序的解析更顺畅
```
## 模块化

### CommonJS  (require) 
#### 描述： 每个文件就相当于一个模块，有自己的作用域，在一个文件中定义的变量，函数，类都是 私有的，对其它文件不可见。在服务端，模块的加载时运行时同步加载的，在浏览器端，模块需要提前编译打包处理。
#### 特点： 
```
1. 所有代码都运行在模块作用域，不会污染全局作用域
2. 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就会被缓存，以后再加载，会直接读取缓存结果。如果想让模块再运行，就得清除缓存
3. 模块加载是同步的，按照其在代码中出现的顺序
```
### AMD规范 
加载模块完成后就会立即执行该模块，所有模块都执行加载完成后会进入require的回调函数，模块的执行顺序和书写顺序可能不一致。

### CMD规范
加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序完全一致

### ES6模块化
  

### Import export
```
适用场景： 按需加载，条件加载
```

### **require与import的区别**
```
require是将文件  解析路径 => 加载代码 => 包装 => 评估执行 => 最后将结果缓存到 其针对这个模块使用的局部变量中

import 与 export 会将引用和导出的建立连接，引用 与 导出的 内容是 指向同一内存， 所以 模块内的变化 会让引用出也随之动态变化

export 语句输出的接口都是和其对应的值动态绑定的关系，通过该接口渠道的都是模块内部实时的值
```

### 模块化开发的价值
```
1. 避免命名冲突
2. 便于依赖管理
3. 利于性能优化
4. 提高可维护性
5. 利于代码复用
```
### 增量更新 与 缓存

#### Etag
如果Cache-control中的max-age,expires 显示已过期，浏览器 会利用 if-none-match将Etag 发送给服务器，服务器通过判断 Etag是否改变，如果未不变则重定向并重新定义Cache-control字段，如果改变则返回最新的资源 并重新定义Etag