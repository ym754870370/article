1. 浏览器渲染流程
    1.1 接受HTML文件
        字节数据 => 字符串 => Token => Node => DOM
    1.2 接受CSS文件
        字节数据 => 字符串 => Token => Node => CSSDOM
    1.3 将DOM和CSSDOM合为渲染树Render Tree
    1.4 根据渲染树进行布局(回流)，调用GPU绘制，合成图层
2. 为什么操作DOM慢
    因为DOM在渲染引擎中，而JS在JS引擎中，通过JS操作DOM就会涉及两个线程之间的通信，且操作DOM会造成重绘回流等情况，所以就导致了性能上的问题。

3. 什么情况会阻塞渲染
    1. 浏览器在解析到script标签时，会暂停构建DOM，想首屏渲染越快，
        1.1 JS文件应该放在body标签底部。
        1.2 给 script标签添加defer(该JS文件会并行下载，但是会放到HTML解析完成后执行) 或者async属性(针对没有任何依赖的JS文件，表示JS文件下载和解析不会阻塞渲染)

4. 重绘 和 回流
    重绘： 意味着元素发生的改变只影响了节点的一些样式（背景色，边框颜色，文字颜色等），只需要应用新样式绘制这个元素就可以了；
    回流： 意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树；

5.垃圾回收
    浏览器方面
        1. V8采取了一种分代回收的策略，即将堆内存划分为不同的生代，根据各个生代的特点执行不同的垃圾回收算法。V8里主要会处理新生代和老生代两个分区。
        2. V8中所有的对象都是通过堆来分配的，当代码声明变量并且赋值时，该对象的内存就分配到堆中。如果堆内存不够，就继续申请内存，知道大小达到V8限制为止。此时就会触发V8的垃圾回收动作。
        3. 新生代特点是区域小、回收频繁。主要采用Scavenge算法，利用空间换时间。 老生代特点是对象生命周期长，占用内存较多。主要采用Mark-Sweep和Mark-Compact相结合的策略，节省空间。
    JS方面
        早期采用率引用计数的方式，现在采用标记清理的方式进行。垃圾回收程序会动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值

6. 输入URL到浏览器渲染的整个流程
    DNS解析
        1. 操作系统会首先在本地缓存中查询 IP
        2. 没有的话会去系统配置的 DNS 服务器中查询
        3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器，然后去该服务器查询 google 这个二级域名
        4. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP
    TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了

    1. DNS解析域名
    2. TCP三次握手确定服务器端和客户端都可以正常接收和发送数据进行通信下发数据到传输层
    3. 传输层确定数据端口后下发到网络层
    3. 网络层确定IP协议地址指示数据传输到数据链路层
    4. 数据链路层封装数据到数据帧值中再通过物理层进行传输


7. hash 和 history 的区别
    hash: hash通过监听浏览器的onhashchange()事件变化，查找对应的路由规则
    history： 利用H5的 history中新增的两个API pushState() 和 replaceState() 和一个事件onpopstate监听URL变化，可以实现无刷新跳转，但是会像后端请求一次页面，正常服务端会默认指向spa的index.html
    hash 能兼容到IE8， history 只能兼容到 IE10；

8. event.currentTarget 和 event.target( ) 的区别
    event.currentTarget( )
        返回其监听器触发事件的节点，即当前处理该事件的元素、文档或窗口。包括冒泡和捕获事件。
    
    event.target( )
        target 事件属性可返回事件的目标节点（触发该事件的节点，也就是事件发生的源头，事件发生所绑定的那个节点），如生成事件的元素、文档或窗口。也就是说，监听冒泡或者捕获事件的 target，会返回事件发生的那个元素，而不是冒泡或者捕获事件触发的元素。

9. 浏览器缓存
    缓存位置：
        1. Service Worker: 浏览器背后的独立现成，一般用来实现缓存功能
            先注册Service Worker,然后监听install事件，去缓存需要的文件，在通过拦截fetch请求，判断有无缓存返回
        2. Memory Cache: 内存中的缓存，读取高效，持续性很短，会随着进程的释放而释放
        3. Disk Cache 硬盘中的缓存，可以存储大量且时效长，相同地址的资源一旦被硬盘缓存下来，就不会再请求数据。
        4. Push Cache: 当前面三种缓存没有命中是，它才会被使用。缓存时间也很短暂，只在会话(session)中存在，一旦会话结束就被释放。
    缓存策略：
        强缓存： 缓存期间不需要请求 
            Expires: 受限于本地时间，如果修改本地时间，可能会造成缓存失效。
            Cach-Control: 
                max-age 优先级高于Expires
                no-store 不缓存任何响应
                no-cache 资源被缓存，但立即失效，下次会发起请求验证资源是否过期
                public 可以被所有用户缓存

        协商缓存： 如果缓存过期了，就需要发起请求验证资源是否需要更新。
            Last-Modified: 表示本地文件最后修改日期，如果日期更新会将新的资源发送回来。否则 304状态码
            Etag: http1.1 if-none-match会将当前的etag发送给服务器，询问该资源etag是否变动，有变动则将新的资源发送回来，Etag的优先级高于last-modifed

        如果什么缓存策略都没设置，那么浏览器通畅会取响应头中Date减去last-modified值的10%作为缓存时间
            
10. 安全防范知识点
    XSS攻击：
        持久性： 攻击的代码被写入到数据库中，如在评论中去写入 <script>aleat(1)</script>
        非持久性： 一般通过URL参数的方式加入攻击代码，这种攻击浏览器会自动帮助用户防御攻击。

        解决方法：
            1.  对输入的文本内容中的特殊字符进行转义
                    str = str.replace(/&/g, '&amp;')
                    str = str.replace(/</g, '&lt;')
                    str = str.replace(/>/g, '&gt;')
            2. csp： 建立白名单，开发着明确告诉浏览器哪些外部资源可以加载执行，如何拦截是浏览器自己实现的，可以通过这种方式尽量减少XSS攻击。
                主要设置header: Content-Security-plicy
                    default-src ‘self’ 只允许加载本站资源
                    img-src https://* 只允许加载HTTPS协议图片
                    child-src 'none' 允许加载任何框架

    CSRF: 跨站请求伪造
        原理： 攻击这构造出一个后端请求地址，诱导用户点击或者通过某些途径发起请求
            <img src="http://www.domain.com/xxx?comment='attack'"/>

        解决方法：
            1. Get请求不对数据进行更改
            2. 不让第三方网站访问到用户的Cookie，给cookie设置 SameSite属性，chrome51版本增加的属性，表示Cookie不随着跨域请求发送。
            3. 验证Referer: 验证来源地址是否为第三方网站发起
            4. token: 服务器下发一个随机token，每次发请求时将Token携带上，服务器验证Token是否有效

    点击劫持： 利用视觉欺骗的攻击手段。
        原理： 对要攻击的网站通过iframe嵌套的方式嵌入自己的网页中，并将iframe设置透明的，在页面中透出一个按钮诱导用户点击。

        解决方法： 利用X-FRAME-OPTIONS
            ALLOW-FROM: 页面可以再置顶来源的iframe中展示
            SAMEORIGIN:  表示页面可以在相同域名下通过iframe的方式展示

    中间人攻击 
        解决方法： 关闭Http访问，使用https进行通信


11. SPA的原理
    1. 通过监听地址栏的变化，然后利用JS，css来控制组件的替换与更新，从而达到模拟页面跳转的情况

12. JavascriptV8引擎
    早起： sourceCode => AST => 本地代码

    现在： sourcecode => AST(抽象语法树) (Ignition字节码提供更清晰的基线执行模型，简化优化机制) => Bytecode Execute => TurboFan（会根据字节码和热点函数反馈类型生成优化后的机器码，采用sea-of-node编译） => 机器码 => 本地代码


