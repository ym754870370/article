# 学习记录

### 自我介绍
面试官您好，我叫杨明，毕业后从事前端开发工作三年了，先后在搜狐实习，滴滴工作一年半，头条工作两年，工作以来从事的业务方向一直是中后台建设的，能高效的与产品和业务方进行沟通，可以合理的把控多业务线的合作，对于后期维护迭代以及产品的战略构思都有着自己的认知与理解。目前组内采用的技术栈为vue2.6+webpack+kui(公司UI库)，在字节，我主要负责质检业务, TOB的项目本身的整体技术复杂度一般，里面的挑战更多的来自于业务方面，比如： 如何与多平台串联开发合作，如何高效接入(目标0成本开发接入业务)新业务, 如何提升质检同学的效率，技术上 因为我是后期接手质检系统，我主要攻克的最大难题是 将质检从各个接入平台代码库中抽离成独立的项目进行迭代优化，抽离项目时我发现部门内所有项目都是spa模式且基于一套基础构建模板，于是我利用npm包引入的便捷性，将业务代码与架构代码拆分，同时借鉴了vue-cli对项目依赖管理与注入的思想，将公司的依赖配置以及webpack的整体架构进行了封装，利用webpack中merge的快速扩展的特性,并利用shelljs，command，fs去实现文件间的依赖执行。




面试官您好，我叫杨明，从事前端开发工作三年多的时间，先后就职于滴滴，字节和快手，主要负责的业务方向一直在中后台方面，对承接中后台的复杂业务上算有一些经验，在快手这半年来主要是增长了管理以及带团队，跨部门合作沟通方面的经验，在滴滴和字节主要是对业务理解度，技术的广度深度等方面的累积了经验


分为两个模块

1. 初始化模板包
    template: 项目结构，package中会去引入我的基础建设包并调用相关基础建设的入口文件，业务组件库，eslint包
    main.js入口利用commmand监听命令和参数，再通过chalk去进行命令提示，根据具体命令使用shelljs和fs去初始化模板和注入参数。

2. 基础建设包
    主要基于webpack,webpack-dev-server,webpack-merge为底层库去建设, 文件相关依赖和操作主要通过fs和path, 会暴露一个入口配置文件audit_config去扩展。


#### 团队建设：
    合作方面：
    1. 建立信任
    2. 配合产品确立前端所需要的prd文档形式
    3. 配合后端制定 api规范
    4. 配合测试制定测试准入方案，同时给测试上一节课，如何简易判断问题来源于后端还是前端，以正确的形式向前端反馈问题

    5.整理多方问题，对前端进行优化，同时也整理内部对合作的问题，对外进行有效输出

    6. 公共业务组件的封装抽离
    7. 公共方法的封装
    8. 增加报警，埋点

    规范方面
    1. 代码分支管理规范，code review
    2. 排期的统一收口
    
    团队个人：
    1. 情绪开导
    2. 业务能力培养


#### 组件如何抽象
    1. 统一数据源
    2. 归类配置参
    3. 业务逻辑细致化拆分
    4. 特殊定制化考虑插槽实现
    5. 不篡改导入数据，设计好暴露参数
    6. 如果有ts, 定义好各种入参格式，确保组件自身的运行
    7. 组件性能的极致化，减少内存损耗，及时销毁，业务极端场景的充分思考
    



    面对30+后端，6个产品
    1. 需求文档约束，协助制定需求方案
    2. 接口规范
    3. 从0到1整合 前端 后端 测试 产品合作流程
    4. 团队同学的技术培养，需求规划。排期安排
    
    6. 性能优化

组件如何抽象？
1. 合理控制拆分粒度
2. 配置参数的合理设计
3. 保证组件的独立性，不去做组件件依赖，各司其职y
3. 制定好规范

1. 能利用字段有无 控制展示 就不要暴露开关
2. 涉及到数据枚举 都采用外部传入 拒绝内部接口读取 
3. 组件之间尽量保持相互独立，父组件绝不依赖子组件


首先基于webpack库、webpack-merge库、webpack-dev-server库去组装项目配置，利用了chalk去实现高亮提示，利用commander去实现命令监听和参数采集，通过path resolve去实现依赖路径绑定，使用fs, shelljs去实现 模板初始化，利用了script命令去 调用dev,build的包内入口文件, 并提供了audit-config的配置入口，提供base, dev, build三个对象通过merge去扩展webpack配置(如 entry,module,alias)，同时提供common对象去提供相关公司依赖的配置参数，利用 eslint的extends 属性去引入eslint包扩展eslint规范

关于业务组件封装，主要基于Vue.component，可以直接用 VUE实例install的特性 在index.js将组件 当做插件全局通过Vue.use()引入并export,同时每个组件的入口也一并利用install声明后暴露了，利用node的文件管理系统导入webpack入口，并利用webpack的externals属性去提供单个组件引入名，实现按需加载。

shell.test 当前命令目录下是否有当前文件名
shell.cp 拷贝文件内容
fs.mkdir 新建文件夹
fs.readdirSync 同步读取当前目录下所有文件路径


src下 请求io，页面page,组件components, 路由router, 数据层store, 模板入口main.js index.html, 公共方法 utils

spa页面的好处
1. 提升页面切换体验，避免页面的重新加载
2. 减轻服务器压力，只用出数据，不用管展示逻辑和页面的合成
3. 前后端分离式开发

缺点
1. SEO难度大
2. 初次加载耗时长

优化：
1. 


统一脚手架，目的： 增强项目的稳定性，可扩展性，可管理性

1. 减少开发人员配置带来的时间损坏，已经项目学习成本降低
2. 统一项目结构，便于管理，统一技术栈还有相关依赖
3. 初始化就引入公司相关依赖配置
4. eslint规范化配置
5. 消耗少量的人力成本，未来可以带来巨大的收益，如：每个项目自身的学习成本降低，独立基础建设层，让项目性能优化建设更容易，依赖配置规范化管理，收益明显

1. 版本管理

### 框架 VUE: 
1. Vue3 关于 proxy数组劫持有何特殊之处？
    ```javascript
            var proto = [1, 2];
            var obj = new Proxy(proto, {
            get(target, key) {
                console.log('get', key)
                return Reflect.get(target, key)
            },
            set(target, key, value) {
                console.log('set', key)
                return Reflect.set(target, key, value)
            }
            })

            obj.map(v => v);
            VM2869:4 get map
            VM2869:4 get length
            VM2869:4 get constructor
            VM2869:4 get 0

            obj.push(10);
            VM2869:4 get push
            VM2869:4 get length
            VM2869:8 set 2
            VM2869:8 set length
            3

    ```

    几种类型的watcher实例

    每个组件渲染 会产生一个实例

    userWatcher


    
2. vue 数据驱动原理
    思想： 是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据

    核心机制： 观察者模式。

    组成： 
        1. 组件挂载： 将初始数据渲染到真实 DOM 上的过程
            通过调用get去做具体的依赖收集
            每个数据属性都对应一个Observer，每一个Observer会维护一个订阅器Dep实例，Dep内部维护了一个Watcher数组subs, 用来存放所有订阅了该属性的观察者对象，当属性变化时，去执行订阅者的更新函数。dep具备添加Watcher和删除Watcher的能力.
        2. 响应式： 是数据的更新驱动视图的过程
             当set数据时，同通过notify回调 通知到 watcher 再通知到 dep依赖，接着调用 getter的回调去 update数据，更新render函数 然后放到异步事件中 统一更新真实DOM.
             watcher 里面会有对应的update方法，主要是调用getter将vm实例对象的新值赋值给自己。
    
   
3. React 和 Vue 有何区别？
    
    diff算法有什么不同？
    
    key作用有什么不同？

    https://juejin.cn/post/6844904158093377549
        
    相同点： 
        都使用Virtural DOM
        都使用组件化思想，流程基本一致
        都是响应式，推崇单向数据流
        都有成熟的社区，都支持服务端渲染

        vue template/react jsx -> render函数 -> 生成VNode -> 当有变化时，新老VNode diff -> diff算法对比，并真正去更新真实DOM。
    
    不同点：
        1. 核心思想的不同 
            Vue: 降低前端开发的门槛，渐进式的开发体验，数据可变，双向数据绑定
            React: 推崇函数式编程，数据不可变以及单项数据流，让前端使用更好的开发方式。

        2. API差异(设计理念)
            Vue: 较多的黑盒封装，提供丰富的API
            React: api较少，更多的需要开发者自己去实践

        3. 响应式原理不同
            Vue: 依赖收集，派发更新。
            React: 手动派发，api较少，更多的需要开发者自己去实践

        4. diff算法不同
            Vue: 基于snabbdom 虚拟DOM算法库，使用双向链表，边对比，边更新DOM。  https://lq782655835.github.io/blogs/vue/vue-code-2.snabbdom.html
            React: 主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM

        5. 事件机制不同
            Vue:
                1. vue原生事件使用标准的Web事件
                2. Vue组件自定义事件机制，是父子组件通信基础
            React:
                1. React原生事件被包装，所有事件都冒泡到顶层document监听，然后在这里合成事件下发。基于这套，可以跨端使用事件机制，而不是和Web DOM强绑定
                2. React组件上无事件，父子组件通信使用props


4. MVVM组件间通信方式
    父子组件通信方式
        1. props / $emits
        2. $children / $parent
        3. provide / inject
        4. ref / refs
        5. eventBus
        6. $attrs / $listeners
    
7. Vue $nextTick 实现原理
    1. vue用异步队列的方式来控制DOM更新和nextTick回调先后执行
    2. 利用事件循环中microtask的高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕
    3. 因为兼容性问题，vue不得不做了microtask向macrotask的降级方案

9. MVVM思想

10. Vue-load 如何解析编译
    1. 调用 @vue/component-compiler-utils包的parse函数， 将SFC文本解析为AST对象
    2. 遍历AST对象属性，转换为特殊的路径


11. computed 和 watch 的区别
    computed: 计算一个新的属性，属性会被挂载到Vue实例中，gettter执行后会将值缓存，每一个computed都是一个Watcher, 利用依赖收集去监听依赖属性的变化，监听到变化才会重新求值。会在HTML DOM加载后马上执行。

    watch: 则是一个侦听的动作，监听已经存在且已经挂载到Vue实例上的数据，当监听data中属性变化时，会调用$watch()回调函数，去匹配watch对象的属性，然后传入oldV和newV

    执行顺序： computed 再 watch 

12. 如何实现 v-if
    生成ast 条件对象时，v-if 的div 会增加三个属性 if:show,ifConfitions:Array(1),ifProcessed:true， 这个ast 会生成对应的render 函数 利用show属性去告诉render函数 是否生成该节点。


13. 模板编译流程
    $mount => 获取挂载的DOM元素 => 模板编译 => 模板解析AST js对象 => AST生成代码(生成render函数) => $mount挂载 => mountComponent => 实例化watcher => updateComponent => vm._render(生成虚拟DOM) => vm._update(生成真实的DOM)

14. Vue 生命周期
    beforeCreat: 初始化事件，进行数据的观测
    create: 完成具体配置 数据观测 (data observer)，属性和方法的运算，watch/event 事件回调

    beforeMount: 模板解析vue文件为AST对象，并生成render函数 
    mounted: 上线挂载

15. vue组件如何渲染

16. vue如何实现单页面 按需加载： 本质上就是对路由下的组件单独生成js,然后对那些公用的组件合并打包，引入只引入对应的js文件
        1. 利用vue-router,给每一个路由组件生成一个js文件
                {
                    path: '/home',
                    name: 'home',
                    component: resolve => require(['@/components/home'],resolve)
                }
        2. 可以利用webpack的require.ensure()，静态的解析代码中的 require.ensure(), 同时将相同模块添加到一个chunk中，这个新的chunk会被webpack通过jsonp来按需加载，多个路由如何指定相同的chunkName，会合并打包成一个js文件
            {
                path: '/home',
                name: 'home',
                component: r => require.ensure([], () => r(require('@/components/home')), 'demo')
            },
        3. es提案的import()，会将相同webpackChunkName合并打包成一个Js文件，把组件按组分块
            const Home =  () => import(/* webpackChunkName: 'ImportFuncDemo' */ '@/components/home')

17. vue组件如何完成一次数据收集与更新。
    Vue更新Dom是异步执行的，只要侦听到数据变化，Vue会开启一个队列，缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入队列中一次

18. vue实例化流程
    1. 实例化属性合并，包含extend/minxins属性
    2. 初始化组件生命周期标志符
    3. 初始化组件事件系统
    4. 初始化组件render相关属性方法
    5. 调用beforeCreate
    6. 初始化组件依赖注入内容
    7. 初始化state
        1. initProps
        2. initMethods
        3. initData
        4. 初始化computed
        5. 初始化watch
    8. 编译挂载模板 
        1. 获取template模板文件
        2. 将HTML模板文件编译成AST树形结构
        3. 将AST树形结构解析成render函数
        4. 生成render函数，挂载到options中
        5. 挂载DOM, 调用mountComponent方法

### Vue3
    性能能优化点：
        1. PatchFlag: 只有加上PatchFlag,才会被认为是动态的元素，会被追踪属性的修改。
        2. hoistStatic 会将所有的静态节点提升到render方法之外，这样静态节点只会在启动时被创建一次，之后随着每次渲染则直接进行复用
        3. cacheHandler 事件监听缓存， 减少了当前作用域内未更改组件的不必要渲染
        4. StaticNode 静态节点 VUE编译器也会将VDOM转化为纯字符串的HTML
        5. Tree Shaking： 当使用  bundle （webpack etc.） 会默认加上 Tree Shaking
        6. Suspense： 在把一个嵌套组件渲染到页面之前，会在内存中进行渲染，并记录所有存在异步依赖的组件，当所有异步依赖执行完毕后，才会把整个树渲染出来。
        7. Composition API： 函数式API编程
    变动：
        1. monorepo文件维护方式，将不同的模块拆分到package的子目录中
        2. 增加TS
        3. 源码体积优化
        4. 数据劫持优化
        5. 编译优化
### Js: 
1. Promise如何实现 promise.last()
    
2. 深拷贝
    如何判断类型为Map，Set, Date
    * map、set、正则与object之间关系
        * typeof set === 'object'
        * set instanceof Object === true
    * 判断变量类型的方式，typeof 与 symbol
        * typeof
        * instanceof
        * **Object.prototype.toString.call()**判断作为稳妥
    * 需要考虑各种引用类型
        * Map
        * Set
        * Array
        * RegExp
        * Object
        * Date
        项目好坏的考量
    * 需要考虑当前key是否为对象自身的属性
        person.hasOwnProperty(key)

3. ES6 module 与 commonJS区别？ 
    
    3.1 循环依赖问题如何解决？
        require: 
            a执行加载b时，会中断a的执行，去执行b文件，b文件中再加载a，就会导致b中调用的a没有被完全执行，就会造成循环加载的坑。
        import:
            ES6模块的运行机制，遇到模块加载命令import时，不会去执行模块，而是只生成一个引用等到真的要用到时，再去模块内取值。
        
    
    3.2 import / export 与 require / exports 的区别？

        1. import/export  浏览器有一定程度支持，使用上需要在<script>上增加type="module
            require/exports CommonJs只在node层运行使用
        2. require/exports 是运行时动态加载(运行时加载)，
            import/export 是静态编译(编译时存储引用),可以利用promise特性 上线动态加载
        3. require/exports 输出的是一个值的拷贝，import/export 模块输出的是值的引用
        4. import/export 导出的模块默认调用严格模式.
            require/exports 默认不使用严格模式，可以自定义是否使用严格模式

    3.3 require执行方式
    ```javascript
            // require命令第一次加载改脚本就会执行整个脚本，并生成一个对象。

            {
                id: '', // 模块名
                exports: { ... }, // 模块输出的各个接口
                loaded: true, // 当前模块脚本是否执行完毕
                filename: '/home/ruanyf/tmp/a.js', // 文件的绝对路径
                paths: [
                    '/home/ruanyf/tmp/node_modules',
                    '/home/ruanyf/node_modules',
                ], // 可能是当前模块的位置集合
                parent: { Object }, // 父模块
            }

            做的事情： 
            1. Resolution ／ 解析路径 得出真正的绝对路径
                Module._resolveFilename() // 确定模块的绝对路径，如果是内置模块则不含路径返回
            2. Loading ／ 加载代码
                module.load() // 加载模块
                2.1 Wrapping ／ 包装
                    function (exports, require, module, __filename, __dirname) {
                        const m = 1;
                        module.exports.m = m;
                    }
                2.2 Evaluation ／ 评估执行
                2.3 Caching ／ 缓存
    ```
4. 字符串替换

    replaceAll(/(\d{4})/, function(a, b) => { return ;})

5. 节流与防抖


乞丐版
```javascript
    function debounce(fn, time) {
        let timer;
        return () => {
            clearTimeout(timer);
            timer = setTimeout(() => {
                fn(...arguments);
            }, time)
        }
    }


    function throttle(fn, time) {
        let timer;
        return () => {
            if (!timer) {
                setTimeout(() => {
                    fn(...arguments);
                }. time);
            }
        }
    }


```

```javascript
    function debounce(fn, delay) {
        let timer = null;

        return function() {
            let context = this;
            let args = arguments;
            clearTimeout(timer);
            timer = setTimeout(function() {
                fn.apply(context, args);
            }, delay);
        }
    }

    function throttle(func, delay) {
        let rimer = null;
        
        return function() {
            let context = this;
            let args = arguments;
            if (!timer) {
                timer = setTimeout(function() {
                    func.apply(context, args);
                    timer = null;
                }, delay);
            }
        }
    }
```

6. 原型
    ![Alt text](../IMG/原型.png)
```javascript
    funtion a() {}
    b = new a();
    b.__proto__ === a.prototype // true
```

7. async await实现原理

8. 闭包、词法作用域
    闭包是一个基于词法作用域下，有记忆的，且有权访问另外一个函数作用域中变量的函数。
    
    如果嵌套函数是作为返回值返回的或者存储在某处的属性里，那么就会有一个外部引用指向这个嵌套函数，那么嵌套函数就不会被当作垃圾回收，它在作用域链中绑定局部变量的对象也不会被回收。

    是因为一个函数被当前函数作用域外部的变量引用了，除非外部的变量被释放，否则闭包当然不会被回收。

9. JS性能优化
    1. 合并js文件，减少请求次数，
    2. 阻塞式引用 将script标签放在body尾部，无阻赛式引用 可增加defer和async属性。async 下载完成后立即执行 defer 等页面加载完成后再执行
    3. 不适用with,eval语句，减少层级嵌套
    4. 较少DOM的操作次数
    5. 使用事件委托来减少事件处理器的数量
    6. 把最有可能命中的条件放在首位
    7. 用变量去缓存一些常量
    8. 条件多余3使用switch 而不是 if

10. 事件循环
    1. 微观任务
        promise, async, process.nexttick(node独有)，mutationObserver
    
    2. 宏观任务
        script, setTimeOut, setInterval, setImmediate, I/O, UI交互事件
    
    浏览器会优先执行一个宏任务，接下来有异步代码再执行微任务，接着微任务执行完毕如果需要则更新UI，接着执行宏任务开启下一轮eventloop。

    宏任务，由 事件触发线程 维护，微任务则由JS引擎线程维护

    事件触发线程： 当一个事件被触发时，该线程会把当前的任务放到待处理队列的队尾，等待js引擎去处理

    Node中的event loop和浏览器的完全不同，主要分为6个队列，依次执行

    Timer: 执行setTimeout,setInterval的回调,并且是由poll阶段进行控制

    I/O: 执行一轮循环中少数未执行的 I/O 回调

    idle, prepare: node内部实现

    poll: 回到 timer 阶段执行回调,执行 I/O 回调
        当回调队列不为空，则执行回调
        当回调队列为空，如果setImmediate队列存在，则会停止当前阶段直接进入check，如果setImmediate队列不存在，则会等待回调事件并执行，当然会有超时判断。

    check: 执行setImmediate

    close callbacks: close事件

    process.nextTick是独立于事件循环外的nextTick队列，当某个阶段结束 就会优先执行当前队列中的事件

11. typeof 和 instanceof
    typof 可以 判断出 除了null 以外的原始类型， function 会返回 function
    instanceof 会通过原型链机制 判断对象类型

    typeof null 返回'object' 代表对象被什么，但存放了空指针

12. this指向
    1. 箭头函数，包裹箭头函数的普通函数中的this
    2. 普通函数被使用时，使用new 时，this则指向实例化对象，非new，执行时 如果为 fn() 则为window 如果为 parent.fn() 则指向 parent
    3. 如果使用了 call,apply,bind 则指向他们的第一个参数

13. promise为了什么？
    解决回调地域的问题。

14. 基本类型 对象类型
    基本类型中除了 NaN !== NaN 以外 别的都相等， 

15. JSON.stringfy 深拷贝的缺陷， 能否正确返回正则

### DOM操作
1. addEventListener 和 onClick的区别
    1. addEventListener 可以给当前元素绑定多个事件，而 onClick只能给当前元素绑定一个事件,不会重复触发
    2. addEventListener 对任何DOM都是有效的，而 onClick只针对HTML，不适用与(script、meta、html、style、title)
    3. addEventListener 第三个参数 true 代表在捕获阶段执行 false 代表在冒泡阶段执行  默认为false

### 算法： 
1. 有序数组中找k，二分查找

2. 二叉树

3. 链表

4. 快排、归并、冒泡、插入、
        
###  扩展知识
1. http
    http2
        1. 多路复用： 通过一个TCP连接就可以传输所有的请求数据,当发生丢包情况会阻塞所有数据
        2. 二进制编码传输数据
        3. Header压缩
        4. 服务端Push
    http3
        QUIC： 实现TCP传输单个数据流，这样丢包时只会影响一个数据流，底层基于UDP协议实现
        0-RTT：缓存当前会话的上下文
        纠错机制： 当只丢一个包时，可以判断出具体丢失的哪一块，如果丢多包只能采用重传方案
    
    和HTTPS的区别？
        1. https协议需要到ca申请证书
        2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议
        3. 两者连接方式也不同，http端口号是80，而https是443
        4. HTTPS协议是由SSL+HTTP协议构建的可进行加密传输
        5. SSL会在表示层进行加密传输

2. Cookie
    给cookie设置expires(过期时间)，这样的cookie就会具备持久性,未设置则随着退出浏览器就会立即删除cookie


2. 性能优化
    1. 从文件大小考虑
    2. 从 script 标签使用上来考虑
    3. 从 CSS、HTML 的代码书写上来考虑
    4. 从需要下载的内容是否需要在首屏使用上来考虑

    图片优化
        1. 减少像素点
        2. 减少每个像素点能够显示的颜色、
        3. CSS去代替
        3. 小图使用BASE64格式
        4. 正确使用图片格式： 如小图使用SVG 照片使用JPEG

    DNS预解析
        DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP
        <link rel="dns-prefetch" href="//yuchengkai.cn">

    节流、防抖
        * debounce(防抖)：只执行一次，输入框搜索，window.resize
	    * throttle(节流)：间隔时间执行，滚动事件，鼠标不断点击按钮

    预加载
        
        <link rel="prerender" href="http://example.com"> 

    懒加载
        
        懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。

    CDN
        CDN 的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。

3. 跨域方式
        1. 降域：将两个父域相同，子域不同
        如：
                b.yang.com
                a.yang.com
                利用document.domain修改称'yang.com',这样就可以突破浏览器的同源策略限制，来获取或操作对方的元素
                个人认为：主要运用在多页运用中，单页应用域名相同，所以不存在域名跨域

        2. JSONP:
            原理：利用script标签中的src属性不受到同源限制
            使用：
            1. 动态创建script标签，生成src属性，并传递callback参数
            2. 定义数据处理函数,在 window下声明 window[callback]
            3. 服务端接受请求，解析参数，计算数，然后返回回调函数字符串 ： callback(data)
            4. 将回调函数字符串引入页面并作为js去执行: js 执行 window[callback](data)

        3. CORS(Cross-Origin Resource Sharing 跨来源资源共享):是一种跨域访问机制，允许网页从不同的域访问其资源
            CORS原理：
            1. 当使用XMLHttpRequest发送请求时，如果浏览器发现该请求不符合同源策略，给该请求头加上一个请求头：Origin
            2. 后台进行一定的处理，确定接受请求，会加入一个响应头：Access-Control-Allow-Origin
            3. 浏览器判断该响应头中是否包含origin的值，如果包含，浏览器就会处理响应，前端就可以拿到响应数据，如果不包含，浏览器就会直接驳回，前端无法拿到响应数据

        CORS使用：
            前端： 正常使用AJAX发送请求，若跨域，浏览器则会自动加上请求头：Origin
            后端： 若确定接受请求，则在返回结果中加入响应头：Access-Control-Allow-Origin
        CORS优缺点：
            优点：
                1. 使用更为简单方便，更安全
                2. 支持POST请求方法
            缺点：
                1. CORS是一种新型跨域的请求方案，存在一定的兼容问题。

            浏览器将CORS分为两类请求
                1. 简单请求：直接发送ajax,遇到跨域会自动加上origin请求头
                2. 非简单请求：会在正式通信之前，增加一次HTTP查询请求，称为‘预检’请求，浏览器会去询问服务器，当前网页所在域名是否在服务器允许的名单中，以及可以使用哪些HTTP动词和头部信息字段，只有得到肯定答复才会发出正式的XMLHttpRequest请求，否则就会报错

            Cookie发送
            1.浏览器端需要设置：withCredentials属性为true
            2.服务器端设置：Access-Control-Allow-Credentials: true
            3.如果需要发送Cookie,Access-Control-Allow-Origin就不能设置为＊,否则请求会报错

            详细说明：http://www.ruanyifeng.com/blog/2016/04/cors.html
        4. CSST
            利用css3的 content属性进行跨域
        5. Iframe 
            利用postMessage实现页面间通信
        6. WebSocket
            WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现
        7. 后端跨域
            利用后端接口进行相互传递，服务端跨域方案： 1. @CrossOrigin头部加上就可以支持跨域  2. spring4.2  addCorsMappings() 将需要支持跨域的url直接加入
        8. <link><img>

4. SPA加载速度优化
    * HTTP2
    * 合并HTTP请求，如雪碧图，合并css、js文件
    * CDN
    * http缓存
    * Accept-Encoding gzip br deflate
    * 样式表放在头部，js放在尾部，减少代码大小
    * ssr
    * 懒加载
    * 按需加载

5. 前端内存优化

6. HTTP 强缓存 和 弱缓存
    1. no-cache: 禁用缓存，强制客户端向服务器再次验证，不能调用本地缓存，但是仍然可以缓存。
    2. no-store: 所有的内容都不会被缓存到internet或临时文件中
    3. max-age: 响应最大时间范围，超过该时间，向服务器发起请求判断是否使用缓存，当值为0时，缓存服务器需要将请求转发给源服务器，服务器会存文件最后一次修改时间，加上max-age，比对当前时间判断是否过期

    1. ETag: 资源的匹配信息，当文件更新时根据服务器分配的算法(不唯一)计算出的实体标示
### CSS:
1. 响应式布局
    如何定义Rem  在html 标签下设置 font-size标准
2. flex布局
```css
    父盒子属性：
    flex-direction: row / column / row-reverse / column-reverse;主轴的排列顺序 如 从左到右 从上到下
    flex-wrap: wrap(换行) / nowrap(不换行) / wrap-reverse(第一行在下方);
    flex-flow: <flex-direction> || <flex-wrap> 集合上面两个参数

    justify-content: center;水平居中
    align-item: center;垂直居中
    align-content: flex-start | flex-end | center | space-between | space-around | stretch; 定义了多行排列布局方式

    子盒子属性
    order: <number>  决定盒子排列顺序，数值越大越在后面

    flex-grow: 当父级盒子大于所有子盒子面积时，子盒子索取父级盒子的剩余空间来放大自己
    flex-basis: 设置该元素的宽度，会覆盖width的值
    flex-shrink: 当父级盒子小于子盒子面积时，子盒子会缩小自身的宽度
    flex: <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> 上面三个属性的集合

    align-self: auto | flex-start | flex-end | center | baseline | stretch; 可以覆盖父级的align-items属性；决定自己的位置；
```

3. BFC 块级格式化上下文 block fomatting context

    作用： 1. 形成一个独立的容器，容器内的元素不会影响容器外的元素
          2. 同一个BFC下的相邻盒子的margin会发生重叠
          3. 计算BFC高度时，会把float元素计算在内
          4. BFC的区域不会与float box 重叠

    如何产生：
          1. 根元素，即html
          2. float 不为None时
          3. overflow 不为visible时
          4. position absolute fixed
          5. display 值为 inline-block table-cell table-caption

4. 盒模型
    IE盒模型 border-box：width 指content+padding+border 三个部分
    W3C盒模型 content-box: width 指content的作用

5. 元素优先级

6. 用过的伪类

7. 清除浮动的方法

### Webpack
1. webpack配置，loader、plugin 的区别
    
    1. loader: 转换器，要针对资源文件的加载，去编译或转化文件，执行顺序为最后一个先执行然后执行结果作为参数传递至上一个

    2. plugin: 扩展器，主要是偏向于工程层面，如扩展变量，优化性能，增加一些的功能，plugin可以通过其丰富的自定义功能和生命周期时间去控制打包流程的每个环节。

2. webpack性能优化
   1. babel编译优化
   ```javascript
    module.exports = {
        module: {
            rules: [
            {
                // js 文件才使用 babel
                test: /\.js$/,
                loader: 'babel-loader',
                // 只在 src 文件夹下查找
                include: [resolve('src')],
                // 不会去查找的路径
                exclude: /node_modules/
            }
            ]
        }
    }
    // 可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间
    loader: 'babel-loader?cacheDirectory=true'

   ```
    2. HappyPack
    
    HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了

    ```javascript
        module: {
            loaders: [
                {
                test: /\.js$/,
                include: [resolve('src')],
                exclude: /node_modules/,
                // id 后面的内容对应下面
                loader: 'happypack/loader?id=happybabel'
                }
            ]
            },
        plugins: [
            new HappyPack({
                id: 'happybabel',
                loaders: ['babel-loader?cacheDirectory'],
                // 开启 4 个线程
                threads: 4
            })
        ]

    ```

    3. DllPlugin
        DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。
    ```javascript
        // 单独配置在一个文件中
        // webpack.dll.conf.js
        const path = require('path')
        const webpack = require('webpack')
        module.exports = {
            entry: {
                // 想统一打包的类库
                vendor: ['react']
            },
            output: {
                path: path.join(__dirname, 'dist'),
                filename: '[name].dll.js',
                library: '[name]-[hash]'
            },
            plugins: [
                new webpack.DllPlugin({
                // name 必须和 output.library 一致
                name: '[name]-[hash]',
                // 该属性需要与 DllReferencePlugin 中一致
                context: __dirname,
                path: path.join(__dirname, 'dist', '[name]-manifest.json')
                })
            ]
        }
    ```
    4. 代码压缩
    5. Tree Shaking
        Tree Shaking 可以实现删除项中未被引用的代码, Webpack 4，开启生产环境就会自动启动这个优化功能。
目
    6. Uglify-Js-Plugin 支持使用UglifyJS 去压缩优化JS代码
    7. optimize-css-assets-webpack-plugin 对css 重复数据进行删除并压缩
    8. extract-text-webpack-plugin 提取css webpack3
    9. mini-css-extract-plugin 提取css webpack4
    10. webpack-bundle-analyzer 对文件进行可视化展示
    11. Html-webpack-plugin
    
#### 3. webpack 编译流程
        entry: 开始构建的文件入口
        Output: 如何命名输出的文件以及输出的目录
        Module: 模块
        Chunk: 编译输出的产物，主要使用splitChunksPlugin去分割

        1. 用yargs(解决处理命令参数)进行参数解析 解析合并webpack.config.js和shell option配置项，激活webpack 插件的加载
        
        2. 初始化 webpack  发射事件 WebpackOptionsApply: entryOption
            2.1 初始化 Compiler对象, 负责文件监听和启动编译, 全局至于一个Compile实例
            2.2 注册NodeEnvironmentPlugin插件
            2.3 挂载options中的plugin
            2.4 使用webpackOptionsApply初始化基础插件
        
        3. run 开始编译 
            发射事件 
                1. beforeRun
                2. beforeCompile
                3. compile
                4. thisCompilation
                5. compilation
            3.1 调用compiler对象开始编译
            3.2 创建compilation对象：当webpack以开发模式运行时，每当检测到文件变化。一个新的Compilation对象就会被创建，包含了当前的模块资源、编译生成资源、变化的文件，提供了很多事件回调供插件做扩展。
                3.2.1 负责整个编译过程
                3.2.2 内部会保留compiler的引用
                3.2.3 this.entrys 入口
                3.2.4 this.chunks 代码块
                3.2.5 template
                    mainTemplate、chunkTemplate、hotUpdateChunkTemplate、runtimeTemplate、moduleTemplate
        
        4. make事件 触发SingleEntryPlugin 插件执行 分析入口文件，创建模块对象保存到Compilation上

        5. 对module 进行build
            触发回调事件
                1. Compliation: buildModule
                2. Compliation: successModule
                3. Compliation: finishModules
            1. 调用loader进行处理 runLoaders
            2. 使用acom 生成AST, 遍历AST
            3. 如何 遇到require依赖， 创建Dependency加入依赖数组
            4. module处理完毕后 再处理依赖的module
            5. 异步对依赖的模块进行处理build，如果 依赖还有依赖，则进行递归处理

        6. 调用seal方法进行封装，逐次对module和chunk进行整理，生成编译后的源代码、合并、拆分

        7. template.getRenderMainifest.render()
            1. 通过模板chunk生成，_webpack_require()的格式
            2. MainTemplate 处理入口文件的module
            3. ChunkTemplate: 处理非首屏，需要异步加载的module
            4. 生成的资源保存再compilation.assets中

        8. emitAssets 把Assets输出到outpt的path中
        
#### webpack流程
    1. 初始化： 
        启动构建，读取与合并配置参数.
        实例化Compiler.
        实例化Plugin对象，调用apply方法，给每个插件传入compiler实例的引用，便于插件调用webpack提供的API，同时会绑定Compilation对象的回调钩子
        给每一个Entry实例化EntryPlugin,为后面该Entry的递归解析工作做准备
    2. 编译： 从Entry发出，对每个Module穿行调用对应的Loader去翻译文件内容，再找到对应Module依赖的Module，递归地进行编译处理
        1. before-run: 清除缓存
        2. run 启动一次新的编译
        3. watch-run 监听模式下启动的编译，可以获取到哪些文件发生了变化导致重新启动一次新的编译
        4. compile 告诉插件开启新的编译，并传入compiler对象， 代表 整个webpack 从启动到结束的生命周期
        5. complilation： 检测到文件变化，创建一个新的Compilation对象, 只是代表一次新的编译。
                1. 使用loader去转换一个模块
                2. 在用loader对一个模块转换完后，使用Acorn解析转换后的内容，输出对应的抽象语法树(AST),方便webpack后面对代码进行分析
                3. 从配置的入口模块开始，分析AST, 遇到require,import时，便将导入的模块加入到依赖的模块列表中，同时对新找出的依赖模块递归分析，最终整理出所有模块的依赖关系。
                4. 所有模块的及其依赖都通过Loader转换完成后，根据依赖关系生成Chunk.
        6. after-compile 一次Compilation执行完成，这里会根据编译结果，合并出我们最终生成的文件名和文件内容。
        7. invalid: 当遇到文件不存在时，文件编译错误等异常时会触发该事件，该事件不会导致webpack退出
    3. 输出： 对编译后的Module组合成Chunk,把Chunk转换成文件，输出到文件系统
        1. 生成好所有需要输出的文件, 询问插件哪些文件需要输出，哪些不需要
        2. emit 实际输出文件，最后可以通过插件修改输出内容的地方
        3. after-emit 文件输出完毕
        4. done 成功完成一次编译和输出流程



#### webpack如何处理异步模块？
    1. 会提供__webpack_require方法用于加载被分割出去 需要异步加载Chunk对应的文件
    2. 会提供webpackJsonp函数用于从异步加载的文件中安装模块
    3. webpack会将import/export 替换成 webpack自身的写法

#### webpack如何执行插件？
    1. 维护一个Tapable类，实现事件流机制，把各个插件串联到一起
    2. 插件接受两个参数 constructor中接受用户给插件传入的所有配置 ，apply原型方法上接受compile实例

webpack支持require还是import
### 浏览器
1. 浏览器渲染流程
    1.1 接受HTML文件
        字节数据 => 字符串 => Token => Node => DOM
    1.2 接受CSS文件
        字节数据 => 字符串 => Token => Node => CSSDOM
    1.3 将DOM和CSSDOM合为渲染树Render Tree
    1.4 根据渲染树进行布局(回流)，调用GPU绘制，GPU会根据布局树的特点将其转换为层树，合成图层
2. 为什么操作DOM慢
    因为DOM在渲染引擎中，而JS在JS引擎中，通过JS操作DOM就会涉及两个线程之间的通信，且操作DOM会造成重绘回流等情况，所以就导致了性能上的问题。

3. 什么情况会阻塞渲染
    1. 浏览器在解析到script标签时，会暂停构建DOM，想首屏渲染越快，
        1.1 JS文件应该放在body标签底部。
        1.2 给 script标签添加defer(该JS文件会并行下载，但是会放到HTML解析完成后执行) 或者async属性(针对没有任何依赖的JS文件，表示JS文件下载和解析不会阻塞渲染)

4. 重绘 和 回流
    重绘： 意味着元素发生的改变只影响了节点的一些样式（背景色，边框颜色，文字颜色等），只需要应用新样式绘制这个元素就可以了；
    回流： 意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树；

5.垃圾回收
    浏览器方面
        1. V8采取了一种分代回收的策略，即将堆内存划分为不同的生代，根据各个生代的特点执行不同的垃圾回收算法。V8里主要会处理新生代和老生代两个分区。
        2. V8中所有的对象都是通过堆来分配的，当代码声明变量并且赋值时，该对象的内存就分配到堆中。如果堆内存不够，就继续申请内存，知道大小达到V8限制为止。此时就会触发V8的垃圾回收动作。
        3. 新生代特点是区域小、回收频繁。主要采用Scavenge算法，利用空间换时间。 老生代特点是对象生命周期长，占用内存较多。主要采用Mark-Sweep和Mark-Compact相结合的策略，节省空间。
    JS方面
        早期采用率引用计数的方式，现在采用标记清理的方式进行。垃圾回收程序会动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值

6. 输入URL到浏览器渲染的整个流程
    DNS解析(配置好IP)
        1. 操作系统会首先在本地缓存中查询 IP
        2. 没有的话会去系统配置的 DNS 服务器中查询
        3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器，然后去该服务器查询 google 这个二级域名
        4. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP
    TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了

    1. DNS解析域名
    2. TCP三次握手确定服务器端和客户端都可以正常接收和发送数据进行通信下发数据到传输层
    3. 传输层确定数据端口后下发到网络层
    3. 网络层确定IP协议地址指示数据传输到数据链路层
    4. 数据链路层封装数据到数据帧值中再通过物理层进行传输


7. hash 和 history 的区别
    hash: hash通过监听浏览器的onhashchange()事件变化，查找对应的路由规则
    history： 利用H5的 history中新增的两个API pushState() 和 replaceState() 和一个事件onpopstate监听URL变化，可以实现无刷新跳转，但是会像后端请求一次页面，正常服务端会默认指向spa的index.html
    hash 能兼容到IE8， history 只能兼容到 IE10；

8. event.currentTarget 和 event.target( ) 的区别
    event.currentTarget( )
        返回其监听器触发事件的节点，即当前处理该事件的元素、文档或窗口。包括冒泡和捕获事件。
        冒泡或者捕获触发监听事件的 当前元素
    
    event.target( )
        target 事件属性可返回事件的目标节点（触发该事件的节点，也就是事件发生的源头，事件发生所绑定的那个节点），如生成事件的元素、文档或窗口。也就是说，监听冒泡或者捕获事件的 target，会返回事件发生的那个元素，而不是冒泡或者捕获事件触发的元素。
        触发事件的源头

9. 浏览器缓存
    缓存位置：
        1. Service Worker: 浏览器背后的独立现成，一般用来实现缓存功能
            先注册Service Worker,然后监听install事件，去缓存需要的文件，在通过拦截fetch请求，判断有无缓存返回
        2. Memory Cache: 内存中的缓存，读取高效，持续性很短，会随着进程的释放而释放
        3. Disk Cache 硬盘中的缓存，可以存储大量且时效长，相同地址的资源一旦被硬盘缓存下来，就不会再请求数据。
        4. Push Cache: 当前面三种缓存没有命中是，它才会被使用。缓存时间也很短暂，只在会话(session)中存在，一旦会话结束就被释放。
    缓存策略：
        强缓存： 缓存期间不需要请求 
            Expires: 受限于本地时间，如果修改本地时间，可能会造成缓存失效。
            Cach-Control: 
                max-age 优先级高于Expires
                no-store 不缓存任何响应
                ni-cache 资源被缓存，但立即失效，下次会发起请求验证资源是否过期
        协商缓存： 如果缓存过期了，就需要发起请求验证资源是否需要更新。
            Last-Modified: 表示本地文件最后修改日期，如果日期更新会将新的资源发送回来。否则 304状态码
            Etag: if-none-match会将当前的etag发送给服务器，询问该资源etag是否变动，有变动则将新的资源发送回来，Etag的优先级高于last-modifed

        如果什么缓存策略都没设置，那么浏览器通畅会取响应头中Date减去last-modified值的10%作为缓存时间
            
10. 安全防范知识点
    XSS攻击：
        持久性： 攻击的代码被写入到数据库中，如在评论中去写入 <script>aleat(1)</script>
        非持久性： 一般通过URL参数的方式加入攻击代码，这种攻击浏览器会自动帮助用户防御攻击。

        解决方法：
            1.  对输入的文本内容中的特殊字符进行转义
                    str = str.replace(/&/g, '&amp;')
                    str = str.replace(/</g, '&lt;')
                    str = str.replace(/>/g, '&gt;')
            2. csp： 建立白名单，开发着明确告诉浏览器哪些外部资源可以加载执行，如何拦截是浏览器自己实现的，可以通过这种方式尽量减少XSS攻击。
                主要设置header: Content-Security-plicy
                    default-src ‘self’ 只允许加载本站资源
                    img-src https://* 只允许加载HTTPS协议图片
                    child-src 'none' 允许加载任何框架

    CSRF: 跨站请求伪造
        原理： 攻击这构造出一个后端请求地址，诱导用户点击或者通过某些途径发起请求
            <img src="http://www.domain.com/xxx?comment='attack'"/>

        解决方法：
            1. Get请求不对数据进行更改
            2. 不让第三方网站访问到用户的Cookie，给cookie设置 SameSite属性，chrome51版本增加的属性，表示Cookie不随着跨域请求发送。
            3. 验证Referer: 验证来源地址是否为第三方网站发起
            4. toke: 服务器下发一个随机token，每次发请求时将Token携带上，服务器验证Token是否有效

    点击劫持： 利用视觉欺骗的攻击手段。
        原理： 对要攻击的网站通过iframe嵌套的方式嵌入自己的网页中，并将iframe设置透明的，在页面中透出一个按钮诱导用户点击。

        解决方法： 利用X-FRAME-OPTIONS
            ALLOW-FROM: 页面可以再置顶来源的iframe中展示
            SAMEORIGIN:  表示页面可以在相同域名下通过iframe的方式展示

    中间人攻击 
        解决方法： 关闭Http访问，使用https进行通信





### Node
    1. 异常处理
        try catch 可以捕获异常 但是无法捕获异步异常

### 性能优化
    1. 如何优化一个上万行的列表
        1. 实现虚拟滚动，根据列表的高度去以及页面的高度，去算出可视区域应该渲染出的列表，可以多渲染出一些列表内容，利用css的的tasilateY去平移减少重新渲染的次数,同时可以有效利用节流。
        2. 懒渲染
#### event 监听方式
```javascript 
    
    let events = require("events");
    //创建一个事件监听对象
    let emitter = new events.EventEmitter();
    //监听error事件
    emitter.addListener("error", function (e) {
        /*处理异常*/
        console.log(e.message)
    });
    //触发error事件
    emitter.emit("error", new Error('出错啦'));
```
#### process方式
```javascript 
    process.on('uncaughtException', function (e) {
        /*处理异常*/
        console.log(e.message)
    });
    asyncError()
    syncError()
``` 
#### domain方式
```javascript 
    
    let domain = require('domain')
    let d = domain.create()
    d.on('error', function (e) {
        /*处理异常*/
        console.log(e.message)
    })
    d.run(asyncError)
    d.run(syncError)
``` 
### 难点
  1. 继承 https://juejin.cn/post/6844903774964678664
```javascript  
    // 组合继承

    // 把parent的this指向child,也让child中的this可以拿到parent中this的值
    function Parent1() {
        this.name= 'parent1';
    }
    Parent1.prototype.say = function() {console.log('say')}
    function Child1() {
        this.name = 1;

        Parent1.call(this);
        this.type = 'child';
        
    }
    // 把child的构造函数指向 parent
    Child1.prototype = Parent1.prototype;
    a = new Child1();
    b = new Child1();
    console.log(a, b);

    // 寄生组合继承
    function Parent(value) {
        this.val = value;
    }
    Parent.prototype.getValue = function() {
        console.log(this.val);
    }
    function Child(value) {
        Parent.call(this, value);
    }

    Child.prototype = Object.create(Parent.prototype, {
        constructor: {
            value: Child,
            writable: true,
            enumerable: true,
            configurable: true,
        }
    });

    const child = new Child(1);

    child.getValue()




```
  2. 手写 reduce
```javascript
   Array.prototype.myReduce = function(fn, initialValue) {

        let sourceArr = this;

        let accumulator,currentValue,currentIndex;
        if (initialValue) {
            accumulator = initialValue;
            currentIndex = 0;
        } else {
            accumulator = sourceArr[0];
            currentIndex = 1;
        }


        while(currentIndex < sourceArr.length) {
            // 数组中有很多 无值占位 需要过滤
            if (sourceArr.hasOwnProperty(currentIndex)) {
                currentValue = sourceArr[currentIndex];
                accumulator = fn(accumulator, currentValue, currentIndex, sourceArr);
            }
            currentIndex++;
        }


        return accumulator;
   }



```

  3. 手写 promise
```javascript

    function MyPromise(callback) {
            const self = this;
            self.status = 'pending';
            self.data = undefined; // Promise的值

            self.onResolvedCallback = [];
            self.onRejectedCallback = [];
            callback(resolve, reject);

            function resolve(value){
                  if(self.status == 'pending') {
                        self.status = 'resolved';
                        self.data = value;
                        for(let i = 0; i < self.onResolvedCallback.length; i++) {
                              self.onResolvedCallback[i](value)
                        }
                  }

            }

            function reject(error){
                  if(self.status == 'pending') {
                        self.status = 'rejected';
                        self.data = error;
                        // 依次执行失败之后的函数栈
                        for(let i = 0; i < self.onResolvedCallback.length; i++) {
                              self.onResolvedCallback[i](value)
                        }
                  }
            }
      }

      MyPromise.prototype.then = function(onResolved, onRejectd) {
            const self = this;
            let promise2;

            // 根据标准，如果then的参数不是function,则我们需要忽略它，此处以如下方式处理
            onResolved = typeof onResolved === 'function' ? onResolved : function(value){ return value };
            onRejectd = typeof onRejectd === 'function' ? onRejectd : function(value){ return value };
            if(self.status === 'resolved') {
                  return promise2 = new MyPromise(function(resolve, reject){
                        //  setTimeout(() => {
                              try {
                                    const x = onResolved(self.data)
                                    // 如果 .then()传入的依然是promise方法则直接区它的结果做为promise2的结果
                                    if (x instanceof MyPromise) {
                                          x.then(resolve, reject);
                                    }
                                    resolve(x)
                              } catch (e) {
                                    reject(e) // 如果出错则以捕获到的错误做为promise的结果
                              }
                        //  }, 0);
                  })
            }

            if(self.status === 'rejected') {
                  return promise2 = new MyPromise(function(resolve, reject){
                        // setTimeout(() => {
                              try {
                                    const x = onRejectd(self.data)

                                    // 如果 .then()传入的依然是promise方法则直接区它的结果做为promise2的结果
                                    if (x instanceof MyPromise) {
                                          x.then(resolve, reject);
                                    }
                              } catch (e) {
                                    reject(e) // 如果出错则以捕获到的错误做为promise的结果
                              }
                        // }, 0);
                  })
            }

            if(self.status === 'pending') {
                  return promise2 = new MyPromise(function(resolve, reject) {
                        self.onResolvedCallback.push(function(value) {
                              try {
                                    const x = onResolved(self.data);
                                    if(x instanceof MyPromise) {
                                          x.then(resolve, reject)
                                    }
                              } catch (e) {
                                    reject(e)
                              }
                        })

                        self.onRejectedCallback.push(function(reason) {
                              try {
                                    const x = onRejected(self.data);
                                    if(x instanceof MyPromise) {
                                          x.then(resolve, reject)
                                    }
                              } catch (e) {
                                    reject(e)
                              }
                        })
                  })
            } 
      }

```
    vue loader 做了什么处理，加载文件的过程

  4. 手写call 、 apply 、 bind 、 new
```javascript
    Function.prototype.call = function(context) {

        if (type of this !== 'function') throw new TypeError('ERROR');
        
        // context 是父集传入的实例对象
        context = context || window;
        
        // 将 前的方法 放入 context对象中
        context.fn = this; 

        var args = [...arguments].slice(1);

        // 调用当前方法 就会将This 指向到父集对象 context上
        var result = context.fn(...args);
        
        delete context.fn;

        return result;

    }

    Function.prototype.myApply = function(context, args) {
        context = context || window;
        context.fn = this;
        let result = context.fn(...args);
        delete context.fn
        return result;
    }


    Function.prototype.myBind = function(context) {

        const _this = this;

        const args = [...arguments].slice(1)

        const bound = function() {
            // 检测是否为 new 创建
            if (this instanceof bound) {
                return new _this(...args, ...arguments);
            }

            return _this.apply(context, args.concat(...arguments))
        }

        return bound;
    }

    function new(func) {
        const target = {};
        target.__proto__ = func.prototype;
        const res = func.call(target);
        if (typeof(res) == 'object' || typeof(res) == 'function') {
            return res;
        }
        return target;
    }


    function new(fn) {
        const obj = {};
        obj.__proto__ = fn.prototype;
        fn.call(obj);
        return fn;
    }


```





  4. 手写flat
```javascript
    Array.prototype.fakeFlat = function(num = 1) {
        if (!Number(num) || Number(num) < 0) {
            return this;
        }
        let arr = [];
        this.forEach(item => {
            if (Array.isArray(item)) {
                arr = arr.concat(item.fakeFlat(--num));
            } else {
                arr.push(item);
            }
        });
        return arr;
    };
    const arr = [1, [3, 4], , ,];
    arr.fakeFlat()
```


5. 手写 {} () [] 判断正确
```javascript
function res(str) {
	const strArr = Array.from(str);
	
	const zhan = [];
	let isRight = true;
	const left = ['(', '{', '['];
	const right = [')', '}', ']'];
	let item = strArr.shift();
	if (right.includes(item)) {
		return 'error'
	} else {
		zhan.push(item);
	}
	function pie(left, right) {
        if (!right) return false;
		if (left === '{' && right === '}'){
			return true;
		}
		if (left === '[' && right === ']'){
			return true;
		}
		if (left === '(' && right === ')'){
			return true;
		}
		return false;
	}
	
	while(isRight && strArr.length) {
		const item = strArr.shift();
		const index = zhan.length -1;
		if (right.includes(item)) {
			isRight = pie(zhan[index], item);
            zhan.pop();
            if (!isRight) return false;
		} else {
			zhan.push(item);
		}
	}
    if (zhan.length) return false;
	
    return isRight;
}


```

基础组件（通常在组件库里就解决了）
容器型组件（Container）
展示型组件（stateless）
业务组件
通用组件
UI组件
逻辑组件
高阶组件（HOC）



1. vue data 的实现原理
2. webpack 同步和异步的调用
3. loader之间相互冲突如何解决
4. 对象和函数的区别
5. history和hash的区别
6. vue父子组件渲染顺序


7. vue双向绑定的原理
8. vue computed和watch的区别

9. 脚手架实现原理 如何去构建 利用什么技术 如何配置 实现收益
10. 如何实现v-if

11. 事件委托
12. js性能优化
13. 三次握手
14. react setState执行顺序
15. 如何优化移动端头部
16. node 事件循环
17. 浏览器缓存
18. 浏览器解析
19. spa优化
20. webpack 打包后的文件导入导出方式




```javascript
function Promise(fn) {
    const that = this;
    this.status = 'pending';
    this.value = undefined;
    
    this.resolveCallback = [];
    this.rejectCallback = [];

    function resolve(value) {
        if (this.status === 'pending') {
            that.status = 'resolve';
            that.value = value;
            for(let i = 0; i < that.resolveCallback.length; i++) {
                that.resolveCallback[i](value)
            }
        }
    }

    function reject(value) {
        if (that.status === 'pending') {
            that.status = 'reject';
            that.value = value
            for(let i = 0; i < rejectCallback.length; i++) {
                that.rejectCallback[i](value);
            }
        }
    }
    fn(resolve, reject)
}


Promise.prototype.then(onResolve, onReject) {
    const that = this;

    onResolve = typeof onResolve === 'function' ? onResolve : function(value) {return value};
    onReject = typeof onReject === 'function' ? onReject : function(value) {return value};

    if (that.status === 'resolve') {
        return new Promise(function(resolve, reject) {
            try {
                const info = onResolve(that.value);

                if (info instanceof Promise) {
                    info.then(resolve, reject)
                }
                // 同步则会将计算出的返回值 赋给下一次then的参数
                resolve(info)
            } catch {
                reject(e)
            }
        })
    }

    if (that.status === 'reject') {
        return new Promise(function(resolve, reject) {
            try {
                const info = onReject(that.value);

                if (info instanceof Promise) {
                    info.then(resolve, reject);
                }
            } catch {
                reject(e)
            }
        })
    }
    // 解决promise中存在异步回调函数时，则延迟执行所有 回调
    if (that.status === 'pending') {
        return new Promise(function(resolve, reject) {
            that.resolveCallback.push(function(value) {
                try {
                    // 异步回调只会执行结果
                    const info = onResolve(self.value);
                    resolve(info)
                } catch {
                    reject(e)
                }
            })
            that.rejectCallback.push(function(value) {
                try {
                    const info = onReject(value)
                } catch {
                    reject(e)
                }
            })
        })
    }

}




var a = new Promise(resolve => {
    resolve({key: 1});
})
var b = a.then(data => {
    const that = this;
    console.log('kaishi', data);
    that.data = data;
    new Promise(resolve => {
        that.data.key = 3;
        resolve(that.data);
    }).then(data => {
        console.log('shen promise', that.data);
        data.key = 22222;
    })
    console.log('end: ', data);
    return that.data;;
}).then(data => { console.log('haha', data)});



// 节流 使用闭包去记录当前值状态
let jieliu = function(fn, time) {
    let setReq = null;

    return () => {
        if (!setReq) {
            const args = arguments
            setReq = setTimeout(() => {
                fn(...arguments);
                setReq = null;
            }, time);
        }
    }
    
}

// 防抖
let fangdou = function(fn, time) {
    let setReq = null;

    return () => {
        clearTimeout(setReq);
        const args = arguments
        setReq = setTimeout(() => {
            fn(...arguments)
        })
    }
}

```





