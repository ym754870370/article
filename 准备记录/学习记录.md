# 学习记录

## 自我介绍

面试官您好，我叫杨明，毕业后从事前端开发工作两年多，先后在搜狐实习，滴滴工作一年，头条工作两年，工作以来从事的业务一直是toB的，能高效的与多产品乃至业务方进行沟通，有效把控多业务线的合作，对于后期维护迭代以及产品的战略构思都有着自己的认知与理解。目前组内采用的技术栈为vue2.0+webpack+bui(公司UI库)，我目前主要负责组内两个业务大方向之一的 质检业务, TOB的项目本身的整体技术复杂度一般，里面的挑战更多的来自于业务方面，比如： 如何与多平台串联开发合作，如何高效接入(目标0成本开发接入业务)新业务, 如何提升质检同学的效率，技术上 因为我是后期接手质检系统，我主要攻克的最大难题是 将质检从各个接入平台代码库中抽离成独立的项目进行迭代优化，抽离项目时我又发现部门所有项目都是spa且基于一套基础构建模板，于是我做了统一的业务代码与架构代码分离式架构。



组件如何抽象？
1. 合理控制拆分粒度
2. 配置参数的合理设计
3. 保证组件的独立性，不去做组件件依赖，各司其职
3. 制定好规范

1. 能利用字段有无 控制展示 就不要暴露开关
2. 涉及到数据枚举 都采用外部传入 拒绝内部接口读取 
3. 组件之间尽量保持相互独立，父组件绝不依赖子组件

### 框架 VUE: 
1. Vue3 关于 proxy数组劫持有何特殊之处？
    ```javascript
            var proto = [1, 2];
            var obj = new Proxy(proto, {
            get(target, key) {
                console.log('get', key)
                return Reflect.get(target, key)
            },
            set(target, key, value) {
                console.log('set', key)
                return Reflect.set(target, key, value)
            }
            })

            obj.map(v => v);
            VM2869:4 get map
            VM2869:4 get length
            VM2869:4 get constructor
            VM2869:4 get 0

            obj.push(10);
            VM2869:4 get push
            VM2869:4 get length
            VM2869:8 set 2
            VM2869:8 set length
            3

    ```
2. vue 数据驱动原理
    思想： 是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据

    核心机制： 观察者模式。

    组成： 
        1. 组件挂载： 将初始数据渲染到真实 DOM 上的过程
             每个数据对象都对应一个Observer，每一个Observer会维护一个Dep实例，Dep内部维护了一个Watcher数组subs,dep具备添加Watcher和删除Watcher的能力，对数据对象的每个key进行依赖监听收集和派发.
        2. 响应式： 是数据的更新驱动视图的过程
             当set数据时，同通过notify回调 通知到 watcher 再通知到 dep依赖，接着调用 getter的回调去 update数据，更新render函数 然后放到异步事件中 统一更新真实DOM.
    
   
3. React 和 Vue 有何区别？
    
    diff算法有什么不同？
    
    key作用有什么不同？

    https://juejin.cn/post/6844904158093377549
        
    相同点： 
        都使用Virtural DOM
        都使用组件化思想，流程基本一致
        都是响应式，推崇单向数据流
        都有成熟的社区，都支持服务端渲染

        vue template/react jsx -> render函数 -> 生成VNode -> 当有变化时，新老VNode diff -> diff算法对比，并真正去更新真实DOM。
    
    不同点：
        1. 核心思想的不同 
            Vue: 降低前端开发的门槛，渐进式的开发体验，数据可变，双向数据绑定
            React: 推崇函数式编程，数据不可变以及单项数据流，让前端使用更好的开发方式。

        2. API差异(设计理念)
            Vue: 较多的黑盒封装，提供丰富的API
            React: api较少，更多的需要开发者自己去实践

        3. 响应式原理不同
            Vue: 依赖收集，派发更新。
            React: 手动派发，api较少，更多的需要开发者自己去实践

        4. diff算法不同
            Vue: 基于snabbdom 虚拟DOM算法库，使用双向链表，边对比，边更新DOM。  https://lq782655835.github.io/blogs/vue/vue-code-2.snabbdom.html
            Reaact: 主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DO

        5. 事件机制不同
            Vue:
                1. vue原生事件使用标准的Web事件
                2. Vue组件自定义事件机制，是父子组件通信基础
            React:
                1. React原生事件被包装，所有事件都冒泡到顶层document监听，然后在这里合成事件下发。基于这套，可以跨端使用事件机制，而不是和Web DOM强绑定
                2. React组件上无事件，父子组件通信使用props


4. MVVM组件间通信方式


5. 常见路由的组织形式及注意点

6. Vue 双向绑定原理

7. Vue $nextTick 实现原理
    1. vue用异步队列的方式来控制DOM更新和nextTick回调先后执行
    2. 利用事件循环中microtask的高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕
    3. 因为兼容性问题，vue不得不做了microtask向macrotask的降级方案

8. Vue3 有哪些新特性？新的生命周期？

9. MVVM思想

10. Vue-load 如何解析编译 

### Js: 
1. Promise如何实现 promise.last()
    
2. 深拷贝
    如何判断类型为Map，Set, Date
    * map、set、正则与object之间关系
        * typeof set === 'object'
        * set instanceof Object === true
    * 判断变量类型的方式，typeof 与 symbol
        * typeof
        * instanceof
        * **Object.prototype.toString**判断作为稳妥
    * 需要考虑各种引用类型
        * Map
        * Set
        * Array
        * RegExp
        * Object
        * Date

3. ES6 module 与 commonJS区别？ 
    
    3.1 循环依赖问题如何解决？
        require: 
            a执行加载b时，会中断a的执行，去执行b文件，b文件中再加载a，就会导致b中调用的a没有被完全执行，就会造成循环加载的坑。
        import:
            ES6模块的运行机制，遇到模块加载命令import时，不会去执行模块，而是只生成一个引用等到真的要用到时，再去模块内取值。
        
    
    3.2 import / export 与 require / exports 的区别？

        1. import/export  浏览器有一定程度支持，使用上需要在<script>上增加type="module
            require/exports CommonJs只在node层运行使用
        2. require/exports 是运行时动态加载(运行时加载)，
            import/export 是静态编译(编译时存储引用),可以利用promise特性 上线动态加载
        3. require/exports 输出的是一个值的拷贝，import/export 模块输出的是值的引用
        4. import/export 导出的模块默认调用严格模式.
            require/exports 默认不使用严格模式，可以自定义是否使用严格模式

    3.3 require执行方式
    ```javascript
            // require命令第一次加载改脚本就会执行整个脚本，并生成一个对象。

            {
                id: '', // 模块名
                exports: { ... }, // 模块输出的各个接口
                loaded: true, // 当前模块脚本是否执行完毕
                filename: '/home/ruanyf/tmp/a.js', // 文件的绝对路径
                paths: [
                    '/home/ruanyf/tmp/node_modules',
                    '/home/ruanyf/node_modules',
                ], // 可能是当前模块的位置集合
                parent: { Object }, // 父模块
            }

            做的事情： 
            1. Resolution ／ 解析路径 得出真正的绝对路径
                Module._resolveFilename() // 确定模块的绝对路径，如果是内置模块则不含路径返回
            2. Loading ／ 加载代码
                module.load() // 加载模块
                2.1 Wrapping ／ 包装
                    function (exports, require, module, __filename, __dirname) {
                        const m = 1;
                        module.exports.m = m;
                    }
                2.2 Evaluation ／ 评估执行
                2.3 Caching ／ 缓存
    ```
4. 字符串替换

    reolaceAll(/(\d{4})/, function(a, b) => { return ;})

5. 节流与防抖

6. 原型
    ![Alt text](../IMG/原型.png)

7. async await实现原理

8. 闭包、词法作用域
    闭包是一个基于词法作用域下，有记忆的，且有权访问另外一个函数作用域中变量的函数。
    
    如果嵌套函数是作为返回值返回的或者存储在某处的属性里，那么就会有一个外部引用指向这个嵌套函数，那么外部函数就不会被当作垃圾回收，它在作用域链中绑定局部变量的对象也不会被回收。

    是因为一个函数被当前函数作用域外部的变量引用了，除非外部的变量被释放，否则闭包当然不会被回收。
   
### 算法： 
1. 有序数组中找k，二分查找

2. 二叉树

3. 链表

4. 快排、归并、冒泡、插入、
        
###  扩展知识
1. http/2.0优点
    合并请求，并行下载，压缩数据，预先加载

2. 性能优化
    1. 从文件大小考虑
    2. 从 script 标签使用上来考虑
    3. 从 CSS、HTML 的代码书写上来考虑
    4. 从需要下载的内容是否需要在首屏使用上来考虑

    图片优化
        1. 减少像素点
        2. 减少每个像素点能够显示的颜色、
        3. CSS去代替
        3. 小图使用BASE64格式
        4. 正确使用图片格式： 如小图使用SVG 照片使用JPEG

    DNS预解析
        DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP
        <link rel="dns-prefetch" href="//yuchengkai.cn">

    节流、防抖

    预加载
        
        <link rel="prerender" href="http://example.com"> 

    懒加载
        
        懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。

    CDN
        CDN 的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。

3. 跨域方式
        1. 降域：将两个父域相同，子域不同
        如：
                b.yang.com
                a.yang.com
                利用document.domain修改称'yang.com',这样就可以突破浏览器的同源策略限制，来获取或操作对方的元素
                个人认为：主要运用在多页运用中，单页应用域名相同，所以不存在域名跨域

        2. JSONP:
            原理：利用script标签中的src属性不受到同源限制
            使用：
            1. 动态创建script标签，生成src属性，并传递callback参数
            2. 定义数据处理函数
            3. 服务端接受请求，解析参数，计算数，然后返回回调函数字符串
            4. 将回调函数字符串引入页面并作为js去执行

        3. CORS(Cross-Origin Resource Sharing 跨来源资源共享):是一种跨域访问机制，允许网页从不同的域访问其资源
            CORS原理：
            1. 当使用XMLHttpRequest发送请求时，如果浏览器发现该请求不符合同源策略，给该请求头加上一个请求头：Origin
            2. 后台进行一定的处理，确定接受请求，会加入一个响应头：Access-Control-Allow-Origin
            3. 浏览器判断该响应头中是否包含origin的值，如果包含，浏览器就会处理响应，前端就可以拿到响应数据，如果不包含，浏览器就会直接驳回，前端无法拿到响应数据

        CORS使用：
            前端： 正常使用AJAX发送请求，若跨域，浏览器则会自动加上请求头：Origin
            后端： 若确定接受请求，则在返回结果中加入响应头：Access-Control-Allow-Origin
        CORS优缺点：
            优点：
                1. 使用更为简单方便，更安全
                2. 支持POST请求方法
            缺点：
                1. CORS是一种新型跨域的请求方案，存在一定的兼容问题。

            浏览器将CORS分为两类请求
                1. 简单请求：直接发送ajax,遇到跨域会自动加上origin请求头
                2. 非简单请求：会在正式通信之前，增加一次HTTP查询请求，称为‘预检’请求，浏览器会去询问服务器，当前网页所在域名是否在服务器允许的名单中，以及可以使用哪些HTTP动词和头部信息字段，只有得到肯定答复才会发出正式的XMLHttpRequest请求，否则就会报错

            Cookie发送
            1.浏览器端需要设置：withCredentials属性为true
            2.服务器端设置：Access-Control-Allow-Credentials: true
            3.如果需要发送Cookie,Access-Control-Allow-Origin就不能设置为＊

            详细说明：http://www.ruanyifeng.com/blog/2016/04/cors.html
        4. CSST
            利用css3的 content属性进行跨域
        5. Iframe 
            利用postMessage实现页面间通信
        6. WebSocket
            WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现
        7. 后端跨域
            利用后端接口进行相互传递，服务端跨域方案： 1. @CrossOrigin头部加上就可以支持跨域  2. spring4.2  addCorsMappings() 将需要支持跨域的url直接加入
        8. <link><img>

4. SPA加载速度优化
    * HTTP2
    * 合并HTTP请求，如雪碧图，合并css、js文件
    * CDN
    * http缓存
    * Accept-Encoding gzip br deflate
    * 样式表放在头部，js放在尾部，减少代码大小
    * ssr
    * 懒加载
    * 按需加载

5. 前端内存优化

6. HTTP 强缓存 和 弱缓存

### CSS:
1. 响应式布局
    如何定义Rem  在html 标签下设置 font-size标准

### Webpack
1. webpack配置，loader、plugin 的区别
    
    1. loader: 转换器，要针对资源文件的加载，去编译或转化文件，执行顺序为最后一个先执行然后执行结果作为参数传递至上一个

    2. plugin: 扩展器，主要是偏向于工程层面，如扩展变量，优化性能，增加一些的功能，plugin可以通过其丰富的自定义功能和生命周期时间去控制打包流程的每个环节。

2. webpack性能优化
   1. babel编译优化
   ```javascript
    module.exports = {
        module: {
            rules: [
            {
                // js 文件才使用 babel
                test: /\.js$/,
                loader: 'babel-loader',
                // 只在 src 文件夹下查找
                include: [resolve('src')],
                // 不会去查找的路径
                exclude: /node_modules/
            }
            ]
        }
    }
    // 可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间
    loader: 'babel-loader?cacheDirectory=true'

   ```
    2. HappyPack
    
    HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了

    ```javascript
        module: {
            loaders: [
                {
                test: /\.js$/,
                include: [resolve('src')],
                exclude: /node_modules/,
                // id 后面的内容对应下面
                loader: 'happypack/loader?id=happybabel'
                }
            ]
            },
        plugins: [
            new HappyPack({
                id: 'happybabel',
                loaders: ['babel-loader?cacheDirectory'],
                // 开启 4 个线程
                threads: 4
            })
        ]

    ```

    3. DllPlugin
        DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。
    ```javascript
        // 单独配置在一个文件中
        // webpack.dll.conf.js
        const path = require('path')
        const webpack = require('webpack')
        module.exports = {
            entry: {
                // 想统一打包的类库
                vendor: ['react']
            },
            output: {
                path: path.join(__dirname, 'dist'),
                filename: '[name].dll.js',
                library: '[name]-[hash]'
            },
            plugins: [
                new webpack.DllPlugin({
                // name 必须和 output.library 一致
                name: '[name]-[hash]',
                // 该属性需要与 DllReferencePlugin 中一致
                context: __dirname,
                path: path.join(__dirname, 'dist', '[name]-manifest.json')
                })
            ]
        }
    ```
    4. 代码压缩
    5. Tree Shaking
        Tree Shaking 可以实现删除项目中未被引用的代码, Webpack 4，开启生产环境就会自动启动这个优化功能。

### 浏览器
1. 浏览器渲染流程
    1.1 接受HTML文件
        字节数据 => 字符串 => Token => Node => DOM
    1.2 接受CSS文件
        字节数据 => 字符串 => Token => Node => DOM
    1.3 将DOM和CSSDOM合为渲染书Render Tree
    1.4 根据渲染书进行布局(回流)，调用GPU绘制，合成图层
2. 为什么操作DOM慢
    因为DOM在渲染引擎中，而JS在JS引擎中，通过JS操作DOM就会涉及两个线程之间的通信，且操作DOM会造成重绘回流等情况，所以就导致了性能上的问题。

3. 什么情况会阻塞渲染
    1. 浏览器在解析到script标签时，会暂停构建DOM，想首屏渲染越快，
        1.1 JS文件应该放在body标签底部。
        1.2 给 script标签添加defer(该JS文件会并行下载，但是会放到HTML解析完成后执行) 或者async属性(针对没有任何依赖的JS文件，表示JS文件下载和解析不会阻塞渲染)

4. 重绘 和 回流
    重绘： 意味着元素发生的改变只影响了节点的一些样式（背景色，边框颜色，文字颜色等），只需要应用新样式绘制这个元素就可以了；
    回流： 意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树；

5.垃圾回收
    浏览器方面
        1. V8采取了一种分代回收的策略，即将堆内存划分为不同的生代，根据各个生代的特点执行不同的垃圾回收算法。V8里主要会处理新生代和老生代两个分区。
        2. V8中所有的对象都是通过堆来分配的，当代码声明变量并且赋值时，该对象的内存就分配到堆中。如果堆内存不够，就继续申请内存，知道大小达到V8限制为止。此时就会触发V8的垃圾回收动作。
        3. 新生代特点是区域小、回收频繁。主要采用Scavenge算法，利用空间换时间。 老生代特点是对象生命周期长，占用内存较多。主要采用Mark-Sweep和Mark-Compact相结合的策略，节省空间。
    JS方面
        早期采用率引用计数的方式，现在采用标记清理的方式进行。垃圾回收程序会动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值

6. 输入URL到浏览器渲染的整个流程
    DNS解析
        1. 操作系统会首先在本地缓存中查询 IP
        2. 没有的话会去系统配置的 DNS 服务器中查询
        3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器，然后去该服务器查询 google 这个二级域名
        4. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP
    TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了

    1. DNS解析域名
    2. TCP握手下发数据到出书层
    3. 传输层确定数据端口后下发到网络层
    3. 网络层确定IP协议地址指示数据传输到数据链路层
    4. 数据链路层封装数据到数据帧值中再通过物理层进行传输

### 难点
  1. 继承 https://juejin.cn/post/6844903774964678664
```javascript  
    // 组合继承
    function Parent1() {
        this.name= 'parent1';
    }
    Parent1.prototype.say = function() {console.log('say')}
    function Child1() {
        this.name = 1;
        Parent1.call(this);
        this.type = 'child';
        
    }
    Child1.prototype = Parent1.prototype;
    a = new Child1();
    b = new Child1();
    console.log(a, b);

    // 寄生组合继承
    function Parent(value) {
        this.val = value;
    }
    Parent.prototype.getValue = function() {
        console.log(this.val);
    }
    function Child(value) {
        Parent.call(this, value);
    }

    Child.prototype = Object.create(Parent.prototype, {
        constructor: {
            value: Child,
            writable: true,
            enumerable: true,
            configurable: true,
        }
    });

    const child = new Child(1);

    child.getValue()




```
  2. 手写 reduce
```javascript
   Array.prototype.myReduce = function(fn, initialValue) {

        let sourceArr = this;

        let accumulator,currentValue,currentIndex;
        if (initialValue) {
            accumulator = initialValue;
            currentIndex = 0;
        } else {
            accumulator = sourceArr[0];
            currentIndex = 1;
        }


        while(currentIndex < sourceArr.length) {
            // 数组中有很多 无值占位 需要过滤
            if (sourceArr.hasOwnProperty(currentIndex)) {
                currentValue = sourceArr[currentIndex];
                accumulator = fn(accumulator, currentValue, currentIndex, sourceArr);
            }
            currentIndex++;
        }


        return accumulator;
   }



```

  3. 手写 promise
```javascript

    function MyPromise(callback) {
            const self = this;
            self.status = 'pending';
            self.data = undefined; // Promise的值

            self.onResolvedCallback = [];
            self.onRejectedCallback = [];
            callback(resolve, reject);

            function resolve(value){
                  if(self.status == 'pending') {
                        self.status = 'resolved';
                        self.data = value;
                        for(let i = 0; i < self.onResolvedCallback.length; i++) {
                              self.onResolvedCallback[i](value)
                        }
                  }

            }

            function reject(error){
                  if(self.status == 'pending') {
                        self.status = 'rejected';
                        self.data = error;
                        // 依次执行失败之后的函数栈
                        for(let i = 0; i < self.onResolvedCallback.length; i++) {
                              self.onResolvedCallback[i](value)
                        }
                  }
            }
      }

      MyPromise.prototype.then = function(onResolved, onRejectd) {
            const self = this;
            let promise2;

            // 根据标准，如果then的参数不是function,则我们需要忽略它，此处以如下方式处理
            onResolved = typeof onResolved === 'function' ? onResolved : function(value){ return value };
            onRejectd = typeof onRejectd === 'function' ? onRejectd : function(value){ return value };
            console.log('self.status', self.status);
            if(self.status === 'resolved') {
                  return promise2 = new MyPromise(function(resolve, reject){
                        //  setTimeout(() => {
                              try {
                                    const x = onResolved(self.data)
                                    // 如果 .then()传入的依然是promise方法则直接区它的结果做为promise2的结果
                                    if (x instanceof MyPromise) {
                                          x.then(resolve, reject);
                                    }
                                    resolve(x)
                              } catch (e) {
                                    reject(e) // 如果出错则以捕获到的错误做为promise的结果
                              }
                        //  }, 0);
                  })
            }

            if(self.status === 'rejected') {
                  return promise2 = new MyPromise(function(resolve, reject){
                        // setTimeout(() => {
                              try {
                                    const x = onRejectd(self.data)

                                    // 如果 .then()传入的依然是promise方法则直接区它的结果做为promise2的结果
                                    if (x instanceof MyPromise) {
                                          x.then(resolve, reject);
                                    }
                              } catch (e) {
                                    reject(e) // 如果出错则以捕获到的错误做为promise的结果
                              }
                        // }, 0);
                  })
            }

            if(self.status === 'pending') {
                  return promise2 = new MyPromise(function(resolve, reject) {
                        self.onResolvedCallback.push(function(value) {
                              try {
                                    const x = onResolved(self.data);
                                    if(x instanceof MyPromise) {
                                          x.then(resolve, reject)
                                    }
                              } catch (e) {
                                    reject(e)
                              }
                        })

                        self.onRejectedCallback.push(function(reason) {
                              try {
                                    const x = onRejected(self.data);
                                    if(x instanceof MyPromise) {
                                          x.then(resolve, reject)
                                    }
                              } catch (e) {
                                    reject(e)
                              }
                        })
                  })
            } 
      }

```
    vue loader 做了什么处理，加载文件的过程

  4. 手写call 、 apply 、 bind 、 new
```javascript
    Function.prototype.call = function(context) {

        if (type of this !== 'function') throw new TypeError('ERROR');
        
        // context 是父集传入的实例对象
        context = context || window;
        
        // 将 前的方法 放入 context对象中
        context.fn = this; 

        var args = [...arguments].slice(1);

        // 调用当前方法 就会将This 指向到父集对象 context上
        var result = context.fn(...args);
        
        delete context.fn;

        return result;

    }

    Function.prototype.myApply = function(context, args) {
        context = context || window;
        context.fn = this;
        let result = context.fn(...args);
        delete context.fn
        return result;
    }


    Function.prototype.myBind = function(context) {

        const _this = this;

        const args = [...arguments].slice(1)

        const bound = function() {
            // 检测是否为 new 创建
            if (this instanceof bound) {
                return new _this(...args, ...arguments);
            }

            return _this.apply(thisArg, args.concat(...arguments))
        }

        return bound;
    }

    function new(func) {
        const target = {};
        target.__proto__ = func.prototype;
        const res = func.call(target);
        if (typeof(res) == 'object' || typeof(res) == 'function') {
            return res;
        }
        return target;
    }
```


  4. 手写flat
```javascript
    Array.prototype.fakeFlat = function(num = 1) {
        if (!Number(num) || Number(num) < 0) {
            return this;
        }
        let arr = [];
        this.forEach(item => {
            if (Array.isArray(item)) {
                arr = arr.concat(item.fakeFlat(--num));
            } else {
                arr.push(item);
            }
        });
        return arr;
    };
    const arr = [1, [3, 4], , ,];
    arr.fakeFlat()
```





基础组件（通常在组件库里就解决了）
容器型组件（Container）
展示型组件（stateless）
业务组件
通用组件
UI组件
逻辑组件
高阶组件（HOC）
